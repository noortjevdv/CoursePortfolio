---
title: "portfolio"
author: "Noortje van der Veen"
date: "2/23/2022"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    storyboard: true
    theme: "cerulean"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```
```{r}
library(flexdashboard)
library(plotly)
library(ggplot2)
library(tidyverse)
library(spotifyr)
library(compmus)
library(hexbin)
library(shiny)
library(ggpubr)
library(tidymodels)
library(ggdendro)
library(heatmaply)

```

```{r, echo=FALSE}
id <- "81f3df676d604409abfe7d3452016983"
secret <- "4dad5e4ae74e48849e41af9b3bc941c2"
Sys.setenv(SPOTIFY_CLIENT_ID = id)
Sys.setenv(SPOTIFY_CLIENT_SECRET = secret)
```

```{r}
JTNV2020 <- get_playlist_audio_features("", "37i9dQZF1ELZEbCiN09pZG?si=eace51fcd9ac4855")
```


Introduction and datasets
===============================

Column{.tabset .tabset-fade}
---------------------------------------

### INTRO

For my corpus, I will use two of the playlists that spotify made for me. 
The first playlist is **“Jouw topnummers van 2020”** and the second playlist is **“Jouw topnummers van 2021”**. What I find interesting about these playlists is that they are in some way representative of the music that I listened to in 2020 and 2021. I’m interested in seeing if there are specific things that have changed when it comes to my music taste. I think the tracks in these playlists are quite representative when it comes to the music that I listened to during those periods of time.

When comparing two tracks, it seemed most logical to me to compare the number one songs from both years. 
For 2020 that song is : **Why Why Why Why Why - Sault**
For 2021 that song is: I know you, I live you - Chaka Khan


### Typical and Atypical tracks

**Some typical tracks from the 2020 playlist:**

Why Why Why Why Why - Sault

Colors - Black Pumas

Exit music (for a film) - Radiohead

Blue World - Mac Miller

H.f.g.w (Canyons Drunken Rage) - Tame Impala


**Some atypical tracks from the 2020 playlist**:

Fam - sor

Daisy - Ashnikko

Fragments of stasimon of Orestes by Euripides - Petros Tabouris


**Some typical tracks from the 2021 playlist**:

I know you, I live you - Chaka Khan

You Don’t Listen - General Elektriks

Famous - The Internet

Blackstar - David Bowie

Exit music (for a film) - Radiohead


**Some atypical tracks from the 2021 playlist**:

Temporary - Lauren Jauregui

SHUM - Go_A

Symphony No.5: IV. Adagietto. Sehr Langsam - Gustav Mahler


Column {.tabset .tabset-fade}
-----------------------------

### Chart 1

```{r}
JTNV2020
```

***

<iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/4uti3gC6MRxJFVu3P6Zq09?utm_source=generator" width="100%" height="380" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>


### Chart 2

```{r}
JTNV2021 <- get_playlist_audio_features("", "4uti3gC6MRxJFVu3P6Zq09?si=780acfc809e64cb1")
JTNV2021

topnummers <- bind_rows(
  JTNV2020 %>% mutate(category = "JTNV2020"),
  JTNV2021 %>% mutate(category = "JTNV2021")
)

```

Energy{data-navmenu="Features per year"}
===================================

Column{data-width=400}
-----------------------------------

### Summary


***
2020:
```{r, echo=FALSE}
summary(JTNV2020$energy)
```

***
2021:
```{r, echo=FALSE}
summary(JTNV2021$energy)
```

***
In the histogram, you can see the energy count per playlist. The included summary shows that both the median and the mean are not too far apart when you compare the 2020 and 2021 playlists. There is however, some difference when you look at the minimum and maximum energy. In my opinion this would mean that in 2021 I listened to a wider variety of music when it comes to energy.

The second chart shows that the 2020 playlist has a wider density. This could be explained by the minimum and maximum being less far apart, which makes the density wider. 



Column{data-width=600}
-----------------------------------

### Energy Count {data-padding=10}

```{r}
tophisto = topnummers %>%
  ggplot(aes(x = energy)) + geom_histogram(binwidth = 0.1) +
  facet_wrap(~category)

ggplotly(tophisto)
```


### Energy per year 2
```{r}
topviolin = topnummers %>%
  ggplot(aes(x = category, y = energy)) +
  geom_violin()

ggplotly(topviolin)
```

Energy-Valence{data-navmenu="Features per year"}
====================
  
Column{data-width=300}
------------------
  
***
Correlation 2020 - Energy / Valence
```{r}
cor(JTNV2020$energy, JTNV2020$valence)
```

***
Correlation 2021 - Energy / Valence
```{r}
cor(JTNV2021$energy, JTNV2021$valence)
```

***
Energy valence 

The first graph shows the relation between **energy and valence** for both 2020 and 2021. I also calculated the correlation between these two variables. That calculation suggests that there is **more correlation between energy and valence in the 2020 playlist** than in the 2021 playlist. This is visually confirmed by the second chart, which in addition to energy and valence, also shows minor and major. The values seem to be more scattered in the 2021 graph.

Something I found interesting about this graph is that in the 2020 chart, minor songs generally score higher than major songs when it comes to energy. Something I think could explain this is that the top ten songs with the highest energy are all (hard)rock songs. These songs are often quite high in energy, even when they are in a minor key.

Another thing I found interesting about this graph is that the song with both the least energy and valence in the 2021 chart, is actually a song that does not really belong in the playlist. Last year I took a Musicological History course, for which we had to take a listening test, to prove that we were able to recognize a song by hearing it. One of the songs that I struggled with while studying was Symphony No. 5: IV. Adagietto. Sehr langsam by Gustav Mahler. This is the song with the lowest energy and valence. This means that it is not really a representative song, since I didn’t listen to it because I wanted to, but because I had to.


Column{data-width=700, .tabset .tabset-fade}
----------------
  
### Energy Valence {data-padding=10}
  
```{r}
topsmooth = topnummers %>% 
  ggplot(aes(x = valence, y = energy)) + geom_point() + geom_smooth() + 
  facet_wrap(~playlist_name, dir = "v")

ggplotly(topsmooth)
```


### Energy Valence Mode 4
```{r, echo=FALSE}

energy_valence = topnummers %>% 
  mutate(
    mode = ifelse(mode == 0, "Minor", "Major")
  ) %>%
  ggplot( 
    aes(
      x = valence,
      y = energy,
      size = loudness,
      colour = mode
    )
  ) +
  geom_point() +             
  geom_rug(size = 0.1) +     
  geom_text(                 
    aes(
      x = valence,
      y = energy,
      label = label
    ),
    data = 
      tibble(
        label = c(".", "."),
        category = c("JTNV2020", "JTNV2021"),
        valence = c(0.0605, 0.9600),
        energy = c(0.101, 0.967)
      ),
    colour = "black",         
    size = 3,                
    hjust = "left",          
    vjust = "bottom",     
    nudge_x = -0.05,        
    nudge_y = 0.02      
  ) +
  facet_wrap(~category) +     
  scale_x_continuous(      
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),  
    minor_breaks = NULL      
  ) +
  scale_y_continuous(        
    limits = c(0, 1),
    breaks = c(0, 0.50, 1),
    minor_breaks = NULL
  ) +
  scale_colour_brewer(       
    type = "qual",          
    palette = "Paired"      
  ) +
  scale_size_continuous(     
    trans = "exp",           
    guide = "none"          
  ) +
  theme_light() +           
  labs(                  
    x = "Valence",
    y = "Energy",
    colour = "Mode"
  )

ggplotly(energy_valence)

```







Danceability{data-navmenu="Features per year"}
===================

Column 1{data-width=200}
-----------------
***
Danceability says something about how suitable a track is for dancing. This is based on multiple musical elements. Some of those elements are energy, temp, rhythm stability and beat strength. 
The 2020 playlist has a higher median and a higher mean when it comes to the danceability variable. 
What I find interesting about this is that the 2021 playlist had a higher energy mean. 
There was barely any difference between the two playlists when it comes to the average tempo, with the 2021 playlist scoring 1.5 BPM higher on the average tempo. 
When I look at the top ten songs with the highest danceability for both playlists, I don’t see any differences that would give a logical explanation as to why the 2020 playlist has a higher mean danceability. 
When I look at the top ten songs with the lowest danceability, it makes more sense that the 2021 playlist scored lower. There are two songs from a classical music playlist that I had to listen to for a school assignment. Besides that I listened to more rock songs in 2021, and a few of those songs apparently score really low on danceability. 


Column 2{data-width=300, data-padding=20, .tabset .tabset-fade}
-----------

### Summary 

***
2020
```{r}
summary(JTNV2020$danceability)
```

***
2021
```{r}
summary(JTNV2021$danceability)
```


### 2020 Lowest Danceability
```{r}
subJTNV2020 = subset(JTNV2020,select = c(danceability, track.name))

asc.dance.2020 = subJTNV2020 %>%
  arrange(danceability)

asc.dance.2020
```


### 2021 Lowest Danceability
```{r}
subJTNV2021 = subset(JTNV2021,select = c(danceability, track.name))

asc.dance.2021 = subJTNV2021 %>%
  arrange(danceability)

asc.dance.2021
```



Column 3{data-width=500}
---------

### Distribution of Danceability Data. 

```{r}
viz4 <- ggplot(topnummers, aes(x=danceability, fill=playlist_name,
                            text = paste(playlist_name)))+
  geom_density(alpha=0.4, color=NA)+
  scale_fill_manual(values=c("blue", "orange"))+
  labs(x="Danceability", y="Density") +
  guides(fill=guide_legend(title="Playlist"))+
  theme_minimal()+
  ggtitle("Distribution of Danceability Data")

ggplotly(viz4, tooltip=c("text"))
```


Chroma Features{data-navmenu="Features per topsong"}
==========================


Top song of 2020, SAULT - whywhywhywhywhy {.tabset}
---------------------------

### Top song of 2020, SAULT - whywhywhywhywhy, Pitch

```{r, echo=FALSE}

whywhywhy <-
  get_tidy_audio_analysis("4zwq3QUKgMNk0NSLl7fpbP?si=dcd0036a52154ea5") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

whywhywhy %>%
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) %>%
  compmus_gather_chroma() %>% 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c()


```

### Timbre

```{r}
w5 <-
  get_tidy_audio_analysis("4zwq3QUKgMNk0NSLl7fpbP?si=adbccc789d3a4d76") %>% 
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
          compmus_summarise, timbre,
          method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )




w5 %>%
  compmus_gather_timbre() %>%
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = basis,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  scale_fill_viridis_c() +                              
  theme_classic()
```


### Self similarity

```{r}
w5 %>%
  compmus_self_similarity(timbre, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")

```


Top song of 2021, Chaka Khan - I know you, I live you {.tabset}
----------------

### Top song of 2021, Chaka Khan - I know you, I live you, Pitch

```{r}
chaka <-
  get_tidy_audio_analysis("0W8MpnhaImy0oPRkVpRvjI?si=a6fff186744843ec") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

chaka %>%
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) %>%
  compmus_gather_chroma() %>% 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c()

```

### Timbre, 

```{r}
ikyily <-
  get_tidy_audio_analysis("0W8MpnhaImy0oPRkVpRvjI?si=8da5d812dfad4637") %>% 
  compmus_align(bars, segments) %>%                     # Change `bars`
  select(bars) %>%                                      #   in all three
  unnest(bars) %>%                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
          compmus_summarise, timbre,
          method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )



ikyily %>%
  compmus_gather_timbre() %>%
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = basis,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  scale_fill_viridis_c() +                              
  theme_classic()
```


### Self similarity, 

```{r}
ikyily %>%
  compmus_self_similarity(timbre, "cosine") %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")
```




Keys and chords{data-navmenu="Features per year"}
==============

Column {.tabset .tabset-fade}
---------------------

### Key name histogram

```{r}
keynamehist = topnummers %>% 
  ggplot(aes(x = key_name)) + geom_bar(width = 0.5) + facet_wrap(~ playlist_name)

ggplotly(keynamehist)
```

### Key minor major

```{r}
keymode = topnummers %>% 
  ggplot(aes(x = key_mode)) + geom_bar(width = 0.5) + facet_wrap(~ playlist_name) + scale_x_discrete(guide = guide_axis(angle = -90)) 

keymode
```

### Mode
```{r}
ggplot(topnummers, aes(x=mode)) + geom_histogram() + facet_wrap(~playlist_name) + labs(x = "mode: 0 = minor, 1 = major")
```


Tempo features{data-navmenu="Features per year"}
===============

Column{data-width=400}
--------------

***
An observation that I made is that the song with the highest tempo, can actually be viewed in halftime. It's the song parachutes by Jordan Mackampa. The song is in my opinion in halftime so  that would mean that it is not a 193 BPM but 97 BPM. 

***
2020
```{r}
JTNV2020 %>%
  summarize(minTempo = min(tempo), maxTempo = max(tempo))
```

***
2021
```{r}
JTNV2021 %>%
  summarize(minTempo = min(tempo), maxTempo = max(tempo))
```



SD Tempo {.tabset .tabset-fade}
---------

### SD tempo

```{r}
nv2020 <-
  get_playlist_audio_features(
    "",
    "37i9dQZF1ELZEbCiN09pZG?si=d5fbdd58fd4146e3"
  ) %>%
  slice(1:30) %>%
  add_audio_analysis()
nv2021 <-
  get_playlist_audio_features(
    "",
    "4uti3gC6MRxJFVu3P6Zq09?si=9cfd7d2717d24ede"
  ) %>%
  slice(1:30) %>%
  add_audio_analysis()
beide <-
  nv2020 %>%
  mutate(year = "2020") %>%
  bind_rows(nv2021 %>% mutate(year = "2021"))

beide %>%
  mutate(
    sections =
      map(
        sections,                                    # sections or segments
        summarise_at,
        vars(tempo, loudness, duration),             # features of interest
        list(section_mean = mean, section_sd = sd)   # aggregation functions
      )
  ) %>%
  unnest(sections) %>%
  ggplot(
    aes(
      x = tempo,
      y = tempo_section_sd,
      colour = year,
      alpha = loudness
    )
  ) +
  geom_point(aes(size = duration / 60)) +
  geom_rug() +
  theme_minimal() +
  ylim(0, 5) +
  labs(
    x = "Mean Tempo (bpm)",
    y = "SD Tempo",
    colour = "Year",
    size = "Duration (min)",
    alpha = "Volume (dBFS)"
  )
```

### Mean tempo

```{r}
"tempo mean" = topnummers %>% 
  ggplot(aes(x = playlist_name, y = tempo)) +
  stat_summary(fun = mean,
               geom = "pointrange",
               fun.min = min,
               fun.max = max) 

ggplotly(`tempo mean`)
```

### Tempo histogram

```{r}
tempohistogram = ggplot(topnummers, aes(x=tempo)) + 
  geom_histogram(color="black", fill="white") + 
  facet_wrap(~playlist_name) 

ggplotly(tempohistogram)
```


### time signature - tempo -mode

```{r}
timesigtempo = ggplot(topnummers, aes(x = time_signature, y = tempo, color = as.factor(mode))) +
  geom_point(alpha = 0.5) + labs(title = "Time signature, tempo and mode",
                       x = "Time Signature",
                       y = "Tempo",
                       color = "Mode") +
  
  facet_wrap(~playlist_name) +
  scale_color_manual(values = c("pink", "coral")) +  
  scale_color_discrete(labels = c("minor", "major"))

ggplotly(timesigtempo)
```


Key per song{data-navmenu="Features per topsong"}
==============

Column {.tabset .tabset-fade}
------------------

### chordograms for my top songs, I know you, I live you

```{r}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )


ikyily2 <-
  get_tidy_audio_analysis("0W8MpnhaImy0oPRkVpRvjI?si=8da5d812dfad4637") %>%
  compmus_align(sections, segments) %>%
  select(sections) %>%
  unnest(sections) %>%
  mutate(
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "mean", norm = "manhattan"
      )
  )

ikyily2 %>% 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "")
```


### why why why why why

```{r}
w52  <-
  get_tidy_audio_analysis("4zwq3QUKgMNk0NSLl7fpbP?si=adbccc789d3a4d76") %>%
  compmus_align(sections, segments) %>%
  select(sections) %>%
  unnest(sections) %>%
  mutate(
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "mean", norm = "manhattan"
      )
  )

w52 %>% 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "")
```









Speechiness and Acousticness{data-navmenu="Features per year"}
============

Means{data-width=300}
----------
### Means
mean speechiness 2020
```{r}
mean(JTNV2020$speechiness)
```

mean speechiness 2021
```{r}
mean(JTNV2021$speechiness)
```

mean acousticness 2020
```{r}
mean(JTNV2020$acousticness)
```

mean acousticness 2021
```{r}
mean(JTNV2021$acousticness)
```


### Explaination
As you can see, the mean for acousticness is higher for the 2021 playlist and the mean for speechiness is higher for the 2020 playlist. The 'outlier' that can be seen in the histogram for the 2020 playlist is a rap song called D/Vision by JID. The fact that it is a rap song explains the high level of speechiness. Most of the songs with high acousticness are classical songs, of which some are from a classical playlist that I had to study for a school assignment. 

Graphs{data-width=700, .tabset .tabset-fade}
----------

### Histogram Speechiness

```{r}
speechihist = topnummers %>%
  ggplot(aes(x = speechiness)) + geom_histogram() + facet_wrap(~playlist_name, dir = "v")

ggplotly(speechihist)
```

### Histogram Acousticness

```{r}
acousthist = topnummers %>%
  ggplot(aes(x = acousticness)) + geom_histogram() + facet_wrap(~playlist_name, dir = "v")

ggplotly(acousthist)
```


### Acousticness - Speechiness


```{r}
acsp = topnummers %>% 
  ggplot(aes(x = speechiness, y = acousticness)) + geom_point(alpha = 0.7) + geom_smooth() + 
  facet_wrap(~playlist_name, dir = "v")

ggplotly(acsp)
```



Dendograms{data-navmenu="Features per year"}
==============

Text{data-width=300}
---------


Dendogram{.tabset .tabset-fade}
----------

### 2020
```{r}
mark2020 <-
  get_playlist_audio_features("", "37i9dQZF1ELZEbCiN09pZG?si=d70969c7136a48f6") %>%
  add_audio_analysis() %>%
  mutate(
    segments = map2(segments, key, compmus_c_transpose),
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "mean", norm = "manhattan"
      ),
    timbre =
      map(
        segments,
        compmus_summarise, timbre,
        method = "mean"
      )
  ) %>%
  mutate(pitches = map(pitches, compmus_normalise, "clr")) %>%
  mutate_at(vars(pitches, timbre), map, bind_rows) %>%
  unnest(cols = c(pitches, timbre))

mark2020_juice <-
  recipe(
    track.name ~
      danceability +
      energy +
      loudness +
      speechiness +
      acousticness +
      instrumentalness +
      liveness +
      valence +
      tempo +
      duration +
      C + `C#|Db` + D + `D#|Eb` +
      E + `F` + `F#|Gb` + G +
      `G#|Ab` + A + `A#|Bb` + B +
      c01 + c02 + c03 + c04 + c05 + c06 +
      c07 + c08 + c09 + c10 + c11 + c12,
    data = mark2020
  ) %>%
  step_center(all_predictors()) %>%
  step_scale(all_predictors()) %>% 
  # step_range(all_predictors()) %>% 
  prep(mark2020 %>% mutate(track.name = str_trunc(track.name, 20))) %>%
  juice() %>%
  column_to_rownames("track.name")

goed2020.20 = mark2020_juice %>%
  slice(1:20)

jtnv2020mark_dist <- dist(goed2020.20, method = "euclidean")

jtnv2020mark_dist %>% 
  hclust(method = "single") %>% # Try single, average, and complete.
  dendro_data() %>%
  ggdendrogram()

```


### 2021

```{r}
mark2021 <-
  get_playlist_audio_features("", "4uti3gC6MRxJFVu3P6Zq09?si=abc053435c0e4bc7") %>%
  add_audio_analysis() %>%
  mutate(
    segments = map2(segments, key, compmus_c_transpose),
    pitches =
      map(segments,
          compmus_summarise, pitches,
          method = "mean", norm = "manhattan"
      ),
    timbre =
      map(
        segments,
        compmus_summarise, timbre,
        method = "mean"
      )
  ) %>%
  mutate(pitches = map(pitches, compmus_normalise, "clr")) %>%
  mutate_at(vars(pitches, timbre), map, bind_rows) %>%
  unnest(cols = c(pitches, timbre))

mark2021_juice <-
  recipe(
    track.name ~
      danceability +
      energy +
      loudness +
      speechiness +
      acousticness +
      instrumentalness +
      liveness +
      valence +
      tempo +
      duration +
      C + `C#|Db` + D + `D#|Eb` +
      E + `F` + `F#|Gb` + G +
      `G#|Ab` + A + `A#|Bb` + B +
      c01 + c02 + c03 + c04 + c05 + c06 +
      c07 + c08 + c09 + c10 + c11 + c12,
    data = mark2021
  ) %>%
  step_center(all_predictors()) %>%
  step_scale(all_predictors()) %>% 
  # step_range(all_predictors()) %>% 
  prep(mark2021 %>% mutate(track.name = str_trunc(track.name, 20))) %>%
  juice() %>%
  column_to_rownames("track.name")

goed2021.20 = mark2021_juice %>%
  slice(1:20)

jtnv2021mark_dist <- dist(goed2021.20, method = "euclidean")

jtnv2021mark_dist %>% 
  hclust(method = "single") %>% # Try single, average, and complete.
  dendro_data() %>%
  ggdendrogram()
```


### Heat map 2020

```{r}
goed2020.20 = mark2020_juice %>%
  slice(1:20)

heatmaply(
  goed2020.20,
  hclustfun = hclust,
  hclust_method = "average",  # Change for single, average, or complete linkage.
  dist_method = "euclidean"
)
```


### Heat map 2021

```{r}
goed2021.20 = mark2021_juice %>%
  slice(1:20)

heatmaply(
  goed2021.20,
  hclustfun = hclust,
  hclust_method = "average",  # Change for single, average, or complete linkage.
  dist_method = "euclidean"
)
```





Tempograms
=============

Text{data-width=300}
---------


Tempograms{.tabset .tabset-fade}
------------

### 2020

```{r}
wx5 <- get_tidy_audio_analysis("4zwq3QUKgMNk0NSLl7fpbP?si=adbccc789d3a4d76")

wx5 %>% tempogram(window_size = 8, hop_size = 1, cyclic = FALSE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()

```


### 2021

```{r}
ikyily2 <-get_tidy_audio_analysis("0W8MpnhaImy0oPRkVpRvjI?si=8da5d812dfad4637")

ikyily2 %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = FALSE) %>%
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()
```

